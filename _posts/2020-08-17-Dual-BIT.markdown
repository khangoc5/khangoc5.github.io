---
layout: post
title:  "2-Dual BIT (Fenwick Tree)"
date:   2020-08-17 08:42:00 +0700
categories: CPP Competitive-Programming
---

Dual Binary Indexed Tree - Dual BIT (or Fenwick Tree).

**Range Updates and Range Queries**

**Probs:**
Cho dãy $A$ gồm $N$ phần tử là các số nguyên dương $A_{1},A_{2},...,A_{N}$. Cho $Q$ thao tác thực hiện lần lượt, thao tác thứ $i$ sẽ có một trong hai loại như sau:
- $1$ $u$ $v$ $x$: Tăng mỗi phần tử từ vị trí $u$ tới vị trí $v$ lên $x$ đơn vị.
- $2$ $u$ $v$: Tính tổng các phần tử từ vị trí $u$ tới vị trí $v$.

```cpp
// @author: khangtq1
#include <bits/stdc++.h>

using namespace std;

#define fto(i, a, b) for(int i = a; i < b; ++i)
#define fdto(i, a, b) for(int i = b - 1; i >= a; --i)
#define rep(i, n) for(int i = 0; i < n; ++i)
#define fill(arr, val) memset(arr, val, sizeof(arr))
#define what_is(x) cerr << #x << " is " << x << "\n"
#define setpre(x) fixed << setprecision(x)

#define all(arr) arr.begin(), arr.end()
#define pb push_back
#define mp make_pair
#define pqueue priority_queue
#define unmap unordered_map //hashmap
#define unset unordered_set //hashset
#define mtset multiset
#define endl '\n'

using ll = long long;
using db = double;
using ii = pair<int, int>;
using vi = vector<int>;

const db PI = acos(-1);

#define MOD 1000000007

void solve();

/// ================================ main ==============================

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt = 1;
	// cin >> tt;
	while(tt--) {
		solve();
	}
	return 0;	
}

/// ================================ solve =============================

#define int long long

/* DUAL BIT */
const int MAX_N = (int) 1e5 + 7;
int B1[MAX_N], B2[MAX_N];
int n, q;

void update(int ft[], int p, int v) {
	for(; p <= n; p += p & -p) {
		ft[p] += v;
	}
}

// Add v to A[a...b] 
void update(int a, int b, int v) {
	update(B1, a, v);
	update(B1, b + 1, -v);
	update(B2, a, v * (a - 1));
	update(B2, b + 1, -v * b);
}

int query(int ft[], int b) {
	int sum = 0;
	for(;b;b-=b & -b) {
		sum += ft[b];
	}
	return sum;
}

// Return sum A[1...b]
int query(int b) {
	return query(B1, b) * b - query(B2, b);
}

// Return sum A[a...b]
int query(int a, int b) {
	return query(b) - query(a-1);
}

void solve() {
	cin >> n >> q;
	fto(i, 1, n + 1) {
		int x; cin >> x;
		update(i, i, x);
	}
	while(q--) {
		int t; cin >> t;
		if(t == 1) {
			int u, v, x;
			cin >> u >> v >> x;
			update(u, v, x);
		} else if(t == 2) {
			int u, v;
			cin >> u >> v;
			cout << query(u, v) << endl;
		}
	}
}

/*
==================================+
INPUT:                            
5 4
1 4 6 2 3
2 1 4
1 2 5 3
1 3 4 5
2 3 5
==================================+
OUTPUT:                           
13
30 
==================================+
*/
```

**Python: Range Updates and Range Queries**

```py
update(ft, p, v):
  for (; p <= N; p += p&(-p))
    ft[p] += v 	 

# Add v to A[a...b] 
update(a, b, v): 	
  update(B1, a, v) 	
  update(B1, b + 1, -v) 	
  update(B2, a, v * (a-1)) 	
  update(B2, b + 1, -v * b) 	 

query(ft, b): 	
  sum = 0 	
  for(; b > 0; b -= b&(-b))
    sum += ft[b]
  return sum

# Return sum A[1...b]
query(b):
  return query(B1, b) * b - query(B2, b)

# Return sum A[a...b]
query(a, b):
  return query(b) - query(a-1)
```

Source: [kartikkukreja.wordpress.com](https://kartikkukreja.wordpress.com/2013/12/02/range-updates-with-bit-fenwick-tree/)
