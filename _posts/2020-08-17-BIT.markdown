---
layout: post
title:  "BIT (Fenwick Tree)"
date:   2020-08-17 08:42:00 +0700
categories: CPP Competitive-Programming
---

Binary Indexed Tree - BIT (or Fenwick Tree).

**Point Updates and Range Queries**

**Ưu điểm:**
1. Bộ nhớ thấp
2. Cài đặt đơn giản
3. Có thể giải được nhiều bài toán về dãy số
4. Thời gian chạy: $O(log_{10}n).$
 
**Nhược điểm:**
Không tổng quát bằng Segment Tree (Một cấu trúc dữ liệu giải thuật khác). Tất cả những bài giải được bằng Fenwick tree đều có thể giải được bằng Segment Tree. Nhưng chiều ngược lại thì không đúng.

**Probs:**
Cho dãy $A$ gồm $N$ phần tử là các số nguyên dương $A_{1},A_{2},...,A_{N}$. Cho $Q$ thao tác thực hiện lần lượt, thao tác thứ $i$ sẽ có một trong hai loại như sau:
- $1$ $p$ $x$: Tăng phần tử ở vị trí $p$ lên $x$ đơn vị.
- $2$ $u$ $v$: Tính tổng các phần tử từ vị trí $u$ tới vị trí $v$.

```cpp
// @author: khangtq1
#include <bits/stdc++.h>

using namespace std;

#define fto(i, a, b) for(int i = a; i < b; ++i)
#define fdto(i, a, b) for(int i = b - 1; i >= a; --i)
#define rep(i, n) for(int i = 0; i < n; ++i)
#define fill(arr, val) memset(arr, val, sizeof(arr))
#define what_is(x) cerr << #x << " is " << x << "\n"
#define setpre(x) fixed << setprecision(x)

#define all(arr) arr.begin(), arr.end()
#define pb push_back
#define mp make_pair
#define pqueue priority_queue
#define unmap unordered_map //hashmap
#define unset unordered_set //hashset
#define mtset multiset
#define endl '\n'

using ll = long long;
using db = double;
using ii = pair<int, int>;
using vi = vector<int>;

const db PI = acos(-1);

#define MOD 1000000007

void solve();

/// ================================ main ==============================

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int tt = 1;
	// cin >> tt;
	while(tt--) {
		solve();
	}
	return 0;	
}

/// ================================ solve =============================

#define int long long

/* BIT */
const int MAX_N = (int) 1e5 + 7;
int fen[MAX_N];
int n, q;
void update(int p, int val){
    for(int i = p; i <= n; i += i & -i)
        fen[i] += val;
}
int sum(int p) {
    int ans = 0;
    for(int i = p; i; i -= i & -i)
        ans += fen[i];
    return ans;
}

void solve() {
	cin >> n >> q;
	fto(i, 1, n + 1) {
		int x; cin >> x;
		update(i, x);
	}
	while(q--) {
		int t; cin >> t;
		if(t == 1) {
			int p, x;
			cin >> p >> x;
			update(p, x);
		} else if(t == 2) {
			int u, v;
			cin >> u >> v;
			cout << sum(v) - sum(u-1) << endl;
		}
	}
}

/*
==================================+
INPUT:                            
6 5
9 2 4 7 4 8    					
1 5 6
2 1 5
1 3 8
1 2 3
2 2 4
==================================+
OUTPUT:                           
32
24 
==================================+
*/
```

**Python: Point Updates and Range Queries**

```py
# Add v to A[p]
update(p, v):
  for (; p <= N; p += p&(-p))
    ft[p] += v 	 

# Return sum A[1...b]	 
query(b): 	
  sum = 0 	
  for(; b > 0; b -= b&(-b))
    sum += ft[b]
  return sum

# Return sum A[a...b]
query(a, b):
  return query(b) - query(a-1)
```

**Python: Range Updates and Point Queries**

```py
# A[] is the original array
# ft[] is the fenwick tree maintaining the diffs initialized with 0
 
# Add v to A[p]
update(p, v):
  for (; p <= N; p += p&(-p))
    ft[p] += v 	 

# Add v to A[a...b] 
update(a, b, v):     
  update(a, v)     
  update(b + 1, -v)  	 

# Return A[b]	 
query(b):     
  sum = 0     
  for(; b > 0; b -= b&(-b))
    sum += ft[b]
  return sum + A[b]
```
